<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de Anatomie a Creierului 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
        }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 400px;
            z-index: 100;
        }
        #ui-container h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #333;
        }
        #feedback {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            min-height: 25px;
        }
        #instructions {
            position: absolute;
            bottom: 15px;
            right: 15px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: right;
            line-height: 1.6;
            z-index: 100;
        }
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: #333;
            z-index: 999;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Găsește partea creierului:</h1>
        <p id="question" style="font-size: 20px;">Se încarcă...</p>
        <div id="feedback"></div>
    </div>
    
    <div id="instructions">
        <strong>Controale:</strong><br>
        Click stânga + Trage: Rotește<br>
        Click dreapta + Trage: Mută<br>
        Rotiță mouse: Zoom
    </div>

    <div id="loading-screen">
        <p>Se încarcă modelul 3D al creierului...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Configurarea de bază a scenei Three.js ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#dbe9ff'); // Un albastru deschis pentru fundal

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // --- Controale Cameră (OrbitControls) ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Efect de "inerție" pentru o mișcare mai fluidă
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.target.set(0, 2, 0); // Punctul în jurul căruia se rotește camera

        // --- Iluminare ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(15, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- Variabile pentru logica jocului ---
        let brainModel;
        const loader = new THREE.GLTFLoader();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const questionElement = document.getElementById('question');
        const feedbackElement = document.getElementById('feedback');
        const loadingScreen = document.getElementById('loading-screen');

        let originalMaterials = {}; // Stochează materialele originale pentru a le restaura
        let lastClickedObject = null;

        // --- Lista de întrebări ---
        // IMPORTANT: Valorile 'targetObjectName' trebuie să corespundă EXACT cu numele mesh-urilor din fișierul brain.glb
        const questions = [
            { questionText: "Cerebelul", targetObjectName: "Cerebellum" },
            { questionText: "Lobul Frontal", targetObjectName: "FrontalLobe" },
            { questionText: "Lobul Temporal", targetObjectName: "TemporalLobe" },
            { questionText: "Lobul Parietal", targetObjectName: "ParietalLobe" },
            { questionText: "Lobul Occipital", targetObjectName: "OccipitalLobe" },
            { questionText: "Trunchiul Cerebral", targetObjectName: "Brainstem" }
        ];
        let currentQuestionIndex = 0;

        // --- Încărcarea modelului 3D al creierului ---
        loader.load(
            'brain.glb', // ATENȚIE: Plasează fișierul 'brain.glb' în același folder cu acest fișier HTML
            function (gltf) {
                brainModel = gltf.scene;
                brainModel.scale.set(1, 1, 1); // Ajustează scara dacă este necesar
                brainModel.position.set(0, 2, 0); // Poziționează modelul în scenă

                // Parcurge toate părțile modelului pentru a activa umbrele și a stoca materialele
                brainModel.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // Stochează materialul original folosind numele unic al obiectului
                        originalMaterials[node.name] = node.material;
                    }
                });
                
                scene.add(brainModel);
                loadingScreen.style.display = 'none'; // Ascunde ecranul de încărcare
                displayNextQuestion(); // Afișează prima întrebare
            },
            undefined,
            function (error) {
                console.error('O eroare a apărut la încărcarea modelului:', error);
                loadingScreen.innerHTML = 'Eroare la încărcarea modelului 3D. Verifică consola pentru detalii.';
            }
        );

        // --- Funcții pentru logica jocului ---
        function displayNextQuestion() {
            if (currentQuestionIndex < questions.length) {
                questionElement.textContent = questions[currentQuestionIndex].questionText;
                feedbackElement.textContent = "";
                feedbackElement.style.color = "";
                resetLastClickedMaterial();
            } else {
                questionElement.textContent = "Felicitări, ai terminat!";
                feedbackElement.textContent = "Ai identificat corect toate părțile.";
                feedbackElement.style.color = "green";
            }
        }
        
        function handleCorrectAnswer(clickedObject) {
            feedbackElement.textContent = "Corect!";
            feedbackElement.style.color = "green";
            
            // Colorează obiectul în verde permanent
            clickedObject.material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            originalMaterials[clickedObject.name] = clickedObject.material; // Salvează noua culoare ca fiind "originală" pentru această rundă

            currentQuestionIndex++;
            setTimeout(displayNextQuestion, 1500); // Treci la următoarea întrebare după 1.5 secunde
        }

        function handleWrongAnswer(clickedObject) {
            feedbackElement.textContent = "Încearcă din nou!";
            feedbackElement.style.color = "red";
            
            // Colorează temporar în roșu
            lastClickedObject = clickedObject;
            clickedObject.material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            
            // Revino la culoarea originală după un timp
            setTimeout(() => {
                resetLastClickedMaterial();
                feedbackElement.textContent = ""; // Șterge feedback-ul
            }, 1000);
        }

        function resetLastClickedMaterial() {
            if (lastClickedObject && originalMaterials[lastClickedObject.name]) {
                lastClickedObject.material = originalMaterials[lastClickedObject.name];
                lastClickedObject = null;
            }
        }

        // --- Gestionarea evenimentului de click ---
        function onMouseClick(event) {
            // Calculează poziția mouse-ului în coordonate normalizate (-1 la +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            // Setează raycaster-ul să pornească de la cameră în direcția mouse-ului
            raycaster.setFromCamera(mouse, camera);
            
            // Verifică dacă raza intersectează modelul creierului
            const intersects = raycaster.intersectObjects(brainModel.children, true);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                console.log('Ai dat click pe:', clickedObject.name); // Util pentru debugging
                
                // Verifică dacă jocul s-a terminat
                if (currentQuestionIndex >= questions.length) return;

                const expectedObjectName = questions[currentQuestionIndex].targetObjectName;

                resetLastClickedMaterial(); // Resetează culoarea obiectului anterior

                if (clickedObject.name === expectedObjectName) {
                    handleCorrectAnswer(clickedObject);
                } else {
                    handleWrongAnswer(clickedObject);
                }
            }
        }

        // --- Bucla de animație ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Important pentru funcționarea controalelor cu "damping"
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('click', onMouseClick);

        // --- Pornirea animației ---
        animate();
    </script>
</body>
</html>
